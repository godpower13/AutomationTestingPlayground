const {By} = require("selenium-webdriver");
module.exports = {
    sampleAppDict: {
        title: 'Sample App',
        description: 'Fill in and submit the form. For successfull login use any non-empty user name and `pwd` as password.',
        loginSuccessfulMsg: (name) => {return `Welcome, ${name}!`},
        loginFailMsg: 'Invalid username/password',
        loginLogoutMsg: 'User logged out.',
        loginBtnName: 'Log In'
    },
    textInputDict: {
        textInputTitle: 'Text Input',
        textInputDescription: 'Entering text with physical keyboard can be different from sending DOM events to an element. This page is specifically desined to illustrate this problem. There are cases when attempts to set a text via DOM events lead to nowhere and the only way to proceed is to emulate real keyboard input at OS level.',
        scenarioTitle: 'Scenario',
        scenarioDotOne: 'Record setting text into the input field and pressing the button.',
        scenarioDotTwo: 'Then execute your test to make sure that the button name is changing.',
        playgroundTitle: 'Playground',
        playgroundDescription: 'Set New Button Name',
        inputTextBoxPlaceholder: 'MyButton',
        buttonText: 'Button That Should Change it\'s Name Based on Input Value'
    },
    classAttributeDict: {
        classAttributeTitle: "Class Attribute",
        classAttributeFirstDesc: "Class attribute of an element may contain more than one class reference. E.g.",
        classAttributeSecondDesc: "XPath selector relying on a class must be well formed. For example, the following will not work:",
        classAttributeThirdDesc: "Correct variant is",
        classAttributeCode1: "<button class=\"btn btn-primary btn-test\">",
        classAttributeCode2: "//button[@class='btn-primary']",
        classAttributeCode3: "//button[contains(concat(' ', normalize-space(@class), ' '), ' btn-primary ')]",
        ScenarioTitle: "Scenario",
        classAttributeScenarioDot1: "Record primary (blue) button click and press ok in alert popup.",
        classAttributeScenarioDot2: "Then execute your test to make sure that it can identify the button using btn-primary class.",
        classAttributePlaygroundTitle: "Playground",
        greenBtn: "Button",
        blueBtn: "Button",
        greenBtn: "Button",
        alertText: 'Primary button pressed'
    },
    shadowDOMDict: {
        shadowDomTitle: "Shadow DOM",
        shadowDomDesc: "This is a page with a Shadow DOM component guid-generator. Using it one can generate a guid and copy it to the clipboard.",
        scenarioTitle: "Scenario",
        scenarioDot1: "Create a test that clicks on and then on buttons. This sequence of steps generates new guid and copies it to the clipboard.",
        scenarioDot2: "Add an assertion step to your test to compare the value from the clipboard with the value of the input field.",
        scenarioDot3: "Then execute the test to make sure that the assertion step is not failing.",
        playgroundTitle: "Playground",
        guiGenTitle: "GUID Generator:",
    },
    overlappedElementDict: {
        overlappedElementTitle: "Overlapped Element",
        overlappedElementDesc: "Entering text to a partially visible element may require scrolling it into view.",
        scenarioTitle: "Scenario",
        scenarioDot1: "Record setting text into the Name input field (scroll element before entering the text).",
        scenarioDot2: "Then execute your test to make sure that the text was entered correctly.",
        playgroundTitle: "Playground",
    },
    nonBreakingSpaceDict: {
        nonBreakingSpaceTitle: "Non-Breaking Space",
        nonBreakingSpaceDesc: "There are cases in test automation when something should obviously work but for some reason it does not. Searching for an element by its text is one of those cases. Text caption may contain non-breaking spaces that have no visual difference from generic spaces.",
        scenarioTitle: "Scenario",
        scenarioDot1: "Use the following xpath to find the button in your test:\n",
        scenarioCode: "//button[text()='My Button']",
        scenarioDot2: "Notice that the XPath does not work. Change the space between 'My' and 'Button' to a non-breaking space. This time the XPath should be valid.",
        playgroundTitle: "Playground",
        buttonTitle: "My Button",

    },
    mouseOverDict: {
        mouseOverTitle: "Mouse Over",
        mouseOverDesc1: "Placing mouse over an element may lead to changes in the DOM tree. For example the element may be modified or replaced. It means if you keep a reference to the original element and will try to click on it - it may not work.",
        mouseOverDesc2: "This puzzle complicates both recording and playback of a test.",
        scenarioTitle: "Scenario",
        scenarioDot1: "Record 2 consecutive link clicks.",
        scenarioDot2: "Execute the test and make sure that click count is increasing by 2.",
        playgroundTitle: "Playground",
        clickMeText: "Click me",
    },
    visibilityDisc: {
        visibilityTitle: "Visibility",
        visibilityDesc: "Checking if element is visible on screen may be a non trivial task.",
        visibilityDot1: "An element may be removed (simplest case),",
        visibilityDot2: "it may have zero height or width,",
        visibilityDot3: "it may be covered by another element,",
        visibilityDot4: "it may be hidden using styles: opacity: 0, visibility: hidden, display: none,",
        visibilityDot5: "or moved offscreen.",
        scenarioTitle: "Scenario",
        scenarioDot1: "Learn locators of all buttons.",
        scenarioDot2: "In your testing scenario press Hide button.",
        scenarioDot3: "Determine if other buttons visible or not.",
        visibilityTitle: "Playground",
        visibilityColorButtons: {
            blue: "Hide",
            red: "Removed",
            yellow: "Zero Width",
            green: "Overlapped",
            opacity: "Opacity",
            visibilityHidden: "Visibility Hidden",
            displayNone: "Display None",
            offScreen: "Offscreen"
        },
    },
    progressBarDict: {
        progressbarTitle: "Progress Bar",
        progressbarDesc: "A web application may use a progress bar to reflect state of some lengthy process. Thus a test may need to read the value of a progress bar to determine if it is time to proceed or not.",
        scenarioTitle: "Scenario",
        scenarioDot1: "Create a test that clicks Start button and then waits for the progress bar to reach 75%. Then the test should click Stop. The less the differnce between value of the stopped progress bar and 75% the better your result.",
        playgroundTitle: "Playground",
        buttonStart: "Start",
        buttonStop: "Stop",
    },
    verifyTextDict: {
        verifyTextTitle: "Verify Text",
        verifyTextDesc: "In general inner text of a DOM element is different from displayed on screen. Browsers normalize text upon rendering, but DOM nodes contain text as it is in HTML markup. For example a browser may show the text as",
        scenarioTitle: "Scenario",
        scenarioDot1: "Create a test that finds an element with Welcome... text.",
        playgroundTitle: "Playground",
        playgroundText: "Welcome UserName!",
    },
    dynamicTableDict: {
        dynamicTableTitle: "Dynamic Table",
        dynamicTableTitle: "Below you see a table where columns and rows change their position upon page reload. Values in cells are random. The table is based on DIVs with ARIA attributes. See WAI-ARIA table design pattern for details.",
        dynamicTableTitle: "Scenario",
        dynamicTableTitle: "For Chrome process get value of CPU load.",
        dynamicTableTitle: "Compare it with value in the yellow label.",
        dynamicTableTitle: "Playground",
    },
    scrollbarsDict: {
        scrollbarsTitle: "Scrollbars",
        scrollbarsDesc: "An application may use native or custom scrollbars and some elements may be out of view. A test scenario may require to ensure that an element is visible on screen and this may require scrolling.",
        scenarioTitle: "Scenario",
        scenarioDot1: "Find a button in the scroll view and record button click.",
        scenarioDot2: "Update your test to automatically scroll the button into a visible area.",
        scenarioDot3: "Then execute your test to make sure it works.",
        playgroundTitle: "Playground",
        hidingButtonTitle: "Hiding Button",
    },
    clickDict: {
        clickTitle: "Click",
        clickDesc: "Physical mouse click and DOM event emulated click are differently handled by browsers. There are still cases, with sometimes hardly identifiable reasons, when an event based click does not work. The solution for this problem is emulating physical mouse click. This page is specifically designed to ignore event based click.",
        scenarioTitle: "Scenario",
        scenarioDot1: "Record button click. The button becomes green after clicking.",
        scenarioDot2: "Then execute your test to make sure that it is able to click the button.",
        playgroundTitle: "Playground",
        buttonText: "Button That Ignores DOM Click Event",
        buttonClassNameBeforeClick : "btn btn-primary",
        buttonClassNameAfterClick: "btn btn-success"
    },
    clientSideDelayDict: {
        clientSideDelayTitle: "Client Side Delay",
        clientSideDelayDesc: "An element may appaear on a page after heavy JavaScript processing on a client side. A test should be able to wait for an element to show up.",
        scenarioTitle: "Scenario",
        scenarioDot1: "Record the following steps. Press the button below and wait for data to appear (15 seconds), click on text of the loaded label.",
        scenarioDot2: "Then execute your test to make sure it waits for label text to appear.",
        playgroundTitle: "Playground",
        buttonText: "Button Triggering Client Side Logic",
        responseMessage: "Data calculated on the client side.",
    },
    ajaxDataDict: {
        ajaxTitle: "AJAX Data",
        ajaxDescription: "An element may appaear on a page after processing of an AJAX request to a web server. A test should be able to wait for an element to show up.",
        scenarioTitle: "Scenario",
        dot1: "Record the following steps. Press the button below and wait for data to appear (15 seconds), click on text of the loaded label.",
        dot2: "Then execute your test to make sure it waits for label text to appear.",
        playgroundTitle: "Playground",
        buttonText: "Button Triggering AJAX Request",
        responseMessage: "Data loaded with AJAX get request.",

    },
    loadDelayDict: {
        loadDelayTitle: "Load Delays",
        loadDelayDesc: "Server response may often come with an unpredictable delay. So a test must be able to patiently wait for page loaded event from a browser.",
        scenarioTitle: "Scenario",
        scenarioDot1: "Navigate to Home page and record Load Delays link click and button click on this page.",
        scenarioDot2: "Then play the test. It should wait until page is loaded.",
        PlaygroundTitle: "Playground",
        ButtonTitle: "Button Appearing After Delay",

    },
    hiddenLayersDict: {
        greenButtonIdAttr: "greenButton",
        blueButtonIdAttr: "blueButton",
        hiddenLayersTitle: "Hidden Layers",
        hiddenLayersDesc: "Some applications use DOM caching techniques. For example, if a user follows a multi step process and each step requires filling data into a form then forms may be cached at the client side along the way. It allows to quickly navigate back and forward through the steps without requesting data from a server. When form is cached it just pushed on-top of z-order stack. It means that an element may be still present in the DOM tree but overlapped with another layer of elements. In this case it is important that a test does not interact with inactive elements becasue they are invisible to a user.\n" +
            "\n",
        scenarioTitle: "Scenario",
        scenarioDot1: "Record button click and then duplicate the button click step in your test.",
        scenarioDot2: "Execute the test to make sure that green button can not be hit twice.",
        playgroundTitle: "Playground",
        buttonTitle: "Button",
    },
    dynamicIDDict: {
        dynamicIDTitle: "Dynamic ID",
        dynamicIDDesc: "Modern applications often generate dynamic IDs for elements. In this case ID is not a reliable attribute for using in element selector. By default many UI automation tools record IDs and this results in tests broken from the very beginning. An automation tool needs a way to instruct it to skip dynamic IDs when XPath is generated for an element.",
        scenarioTitle: "Scenario",
        scenarioDot1: "Record button click.",
        scenarioDot2: "Then execute your test to make sure that ID is not used for button identification.",
        playgroundTitle: "Playground",
        buttonText: "Button with Dynamic ID"
    },
    homePageDict: {
        title: "UI Test Automation\n" +
            "Playground",
        quote: "Quality is not an act, it is a habit.",
        yellowBox: "The purpose of this website is to provide a platform for sharpening UI test automation skills. Use it to practice with your test automation tool. Use it to learn test automation techniques.",
        paragraph: "Different automation pitfalls appearing in modern web applications are described and emulated below."
    }
}
